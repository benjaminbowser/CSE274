// Benjamin Bowser// CSE 274 UApublic final class SortedList<T extends Comparable<T>> {	private class Node {		private T data;		private Node next;		private Node(T dataPortion) {			this(dataPortion, null);		}		private Node(T dataPortion, Node nextNode) {			data = dataPortion;			next = nextNode;		}	}	private Node firstNode;	private int numberOfEntries;	public SortedList() {		firstNode = null;		numberOfEntries = 0;	}	public void add(T newEntry) {		Node currNode = firstNode;		Node prevNode = null;		while (currNode != null && currNode.data.compareTo(newEntry) < 0) {			prevNode = currNode;			currNode = currNode.next;		}		if (prevNode == null) { // insert into beginning			firstNode = new Node(newEntry, currNode);		} else {			Node newNode = new Node(newEntry, currNode);			prevNode.next = newNode;		}		numberOfEntries++;	}	public boolean remove(T anEntry) {		boolean result = false;		Node target = find(anEntry);		if (target != null) {			target.data = firstNode.data;			firstNode = firstNode.next;			numberOfEntries--;			result = true;		}		return result;	}	public T[] toArray() {		@SuppressWarnings("unchecked")		T[] ary = (T[]) new Comparable[numberOfEntries];		Node currNode = firstNode;		for (int i = 0; i < numberOfEntries; i++, currNode = currNode.next) {			ary[i] = currNode.data;		}		return ary;	}	public void display() {		Node currNode = firstNode;		while (currNode != null) {			System.out.print(currNode.data + " ");			currNode = currNode.next;		}	}	public int size() {		return numberOfEntries;	}		public T search(int loc) {		T reply = null;		int current = 0;		Node currNode = firstNode;		while (currNode != null) {			if (current == loc) {				reply = currNode.data;				return reply;			}			else {				current++;				currNode = currNode.next;			}		}		return reply;	}		public String toString() {		String data = "";		Node currNode = firstNode;		while (currNode != null) {			data = data + currNode.data + ", ";			currNode = currNode.next;		}		data = data.substring(0, data.length()-2);		return data;	}		public boolean contains(T anEntry) {		if (find(anEntry) != null) {			return true;		}		return false;	}		private Node find(T anEntry) {		Node result = null;		Node currNode = firstNode;		while (currNode != null) {			if (currNode.data.equals(anEntry)) {				result = currNode;				break;			} else {				currNode = currNode.next;			}		}		return result;	}	}