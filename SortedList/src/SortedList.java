// Not exactly like author's SortedListpublic final class SortedList<T extends Comparable<T>> {	private class Node {		private T data;		private Node next;		private Node(T dataPortion) {			this(dataPortion, null);		}		private Node(T dataPortion, Node nextNode) {			data = dataPortion;			next = nextNode;		}	}	private Node firstNode;	private int numberOfEntries;	public SortedList() {		firstNode = null;		numberOfEntries = 0;	}	public void add(T newEntry) {		Node currNode = firstNode;		Node prevNode = null;		while (currNode != null && currNode.data.compareTo(newEntry) < 0) {			prevNode = currNode;			currNode = currNode.next;		}		if (prevNode == null) { // insert into beginning			firstNode = new Node(newEntry, currNode);		} else {			Node newNode = new Node(newEntry, currNode);			prevNode.next = newNode;		}		numberOfEntries++;	}	public boolean remove(T anEntry) {		return false;	}	public T[] toArray() {		@SuppressWarnings("unchecked")		T[] ary = (T[]) new Comparable[numberOfEntries];		Node currNode = firstNode;		for (int i = 0; i < numberOfEntries; i++, currNode = currNode.next) {			ary[i] = currNode.data;		}		return ary;	}	public void display() {		Node currNode = firstNode;		while (currNode != null) {			System.out.print(currNode.data + " ");			currNode = currNode.next;		}	}	public int size() {		return numberOfEntries;	}		public T search(int loc) {		int current = 0;		Node currNode = firstNode;		while (currNode != null) {			current++;			if (current == loc) {				return currNode.data;			}			else {				currNode = currNode.next;			}		}		return null;	}}