/** * A class of bags whose entries are stored in a fixed-size array. INITIAL, * INCOMPLETE DEFINITION; no security checks *  * @version 4.0 * @author Frank M. Carrano */public final class ArrayBag1<T> implements BagInterface<T> {	private final T[] bag;	private int numberOfEntries;	private static final int DEFAULT_CAPACITY = 25;	/** Creates an empty bag whose capacity is 25. */	public ArrayBag1() {		this(DEFAULT_CAPACITY);	} // end default constructor	/**	 * Creates an empty bag having a given capacity.	 * 	 * @param capacity The integer capacity desired.	 */	public ArrayBag1(int desiredCapacity) {		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] tempBag = (T[]) new Object[desiredCapacity]; // Unchecked cast		bag = tempBag;		numberOfEntries = 0;	} // end constructor	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry The object to be added as a new entry.	 * @return True if the addition is successful, or false if not.	 */	public boolean add(T newEntry) {		boolean result = true;		if (isArrayFull()) {			result = false;		} else { // Assertion: result is true here			bag[numberOfEntries] = newEntry;			numberOfEntries++;		} // end if		return result;	} // end add	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return A newly allocated array of all the entries in this bag.	 */	public T[] toArray() {		// The cast is safe because the new array contains null entries.		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[numberOfEntries]; // Unchecked cast		for (int index = 0; index < numberOfEntries; index++) {			result[index] = bag[index];		} // end for		return result;		// Note: The body of this method could consist of one return statement,		// if you call Arrays.copyOf	} // end toArray	// Returns true if the array bag is full, or false if not.	private boolean isArrayFull() {		return numberOfEntries >= bag.length;	} // end isArrayFull	/**	 * Sees whether this bag is empty.	 * 	 * @return True if this bag is empty, or false if not	 */	public boolean isEmpty() {		return numberOfEntries == 0;	} // end isEmpty	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return The integer number of entries currently in this bag	 */	public int getCurrentSize() {		return numberOfEntries;	} // end getCurrentSize	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return Either the removed entry, if the removal was successful, or null	 */	public T remove() { 		T itemRemoved = null;		if (numberOfEntries > 0) {			numberOfEntries--;			itemRemoved = bag[numberOfEntries];			bag[numberOfEntries] = null;		}		return itemRemoved;			} // end remove	/**	 * Removes one occurrence of a given entry from this bag.	 * 	 * @param anEntry The entry to be removed	 * @return True if the removal was successful, or false otherwise	 */	public boolean remove(T anEntry) { 		for (int i = 0; i < numberOfEntries; i++) { // 			if (bag[i].equals(anEntry)) {				bag[i] = bag[numberOfEntries-1];				bag[numberOfEntries - 1] = null;				numberOfEntries--;				return true;			}		}		return false;	} // end remove	/** Removes all entries from this bag. */	public void clear() { 		for (int i = 0; i < numberOfEntries; i++) { // 				bag[i] = null;				numberOfEntries--;		}	} // end clear	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry The entry to be counted	 * @return The number of times anEntry appears in the bag	 */	public int getFrequencyOf(T anEntry) {		int cnt = 0;		for (int i = 0; i < numberOfEntries; i++) { // not bag.length. what if further elements are null?			if (bag[i].equals(anEntry)) {				cnt++;			}		}		return cnt;	} // end getFrequencyOf	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry The entry to locate	 * @return True if this bag contains anEntry, or false otherwise	 */	public boolean contains(T anEntry) {		for (int i = 0; i < numberOfEntries; i++) { 			if (bag[i].equals(anEntry)) {				return true;			}		}		return false;		} // end contains} // end ArrayBag1